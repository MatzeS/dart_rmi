// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'standard_object.dart';

// **************************************************************************
// InvokerGenerator
// **************************************************************************

class _$RemoteFutureInvoker {
  static dynamic invoke(Invocation invocation, RemoteFuture target) {
    if (invocation.isMethod && #provideRemote == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 1; i++)
        positionalArguments.add(null);

      return target.provideRemote(
        positionalArguments[0],
      );
    }
    if (invocation.isGetter && #hashCode == invocation.memberName) {
      return target.hashCode;
    }
    if (invocation.isGetter && #runtimeType == invocation.memberName) {
      return target.runtimeType;
    }
    if (invocation.isMethod && #asStream == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 0; i++)
        positionalArguments.add(null);

      return target.asStream();
    }
    if (invocation.isMethod && #catchError == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 1; i++)
        positionalArguments.add(null);

      return target.catchError(positionalArguments[0],
          test: invocation.namedArguments[#test]);
    }
    if (invocation.isMethod && #then == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 1; i++)
        positionalArguments.add(null);

      return target.then(positionalArguments[0],
          onError: invocation.namedArguments[#onError]);
    }
    if (invocation.isMethod && #whenComplete == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 1; i++)
        positionalArguments.add(null);

      return target.whenComplete(
        positionalArguments[0],
      );
    }
    if (invocation.isMethod && #timeout == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 1; i++)
        positionalArguments.add(null);

      return target.timeout(positionalArguments[0],
          onTimeout: invocation.namedArguments[#onTimeout]);
    }
    if (invocation.isMethod && #== == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 1; i++)
        positionalArguments.add(null);

      return target == positionalArguments[0];
    }
    if (invocation.isMethod && #toString == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 0; i++)
        positionalArguments.add(null);

      return target.toString();
    }
    if (invocation.isMethod && #noSuchMethod == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 1; i++)
        positionalArguments.add(null);

      return target.noSuchMethod(
        positionalArguments[0],
      );
    }
    if (invocation.isMethod && #then == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 1; i++)
        positionalArguments.add(null);

      return target.then(positionalArguments[0],
          onError: invocation.namedArguments[#onError]);
    }
    if (invocation.isMethod && #catchError == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 1; i++)
        positionalArguments.add(null);

      return target.catchError(positionalArguments[0],
          test: invocation.namedArguments[#test]);
    }
    if (invocation.isMethod && #whenComplete == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 1; i++)
        positionalArguments.add(null);

      return target.whenComplete(
        positionalArguments[0],
      );
    }
    if (invocation.isMethod && #asStream == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 0; i++)
        positionalArguments.add(null);

      return target.asStream();
    }
    if (invocation.isMethod && #timeout == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 1; i++)
        positionalArguments.add(null);

      return target.timeout(positionalArguments[0],
          onTimeout: invocation.namedArguments[#onTimeout]);
    }
  }
}

class _$RemoteStreamInvoker {
  static dynamic invoke(Invocation invocation, RemoteStream target) {
    if (invocation.isMethod && #provideRemote == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 1; i++)
        positionalArguments.add(null);

      return target.provideRemote(
        positionalArguments[0],
      );
    }
    if (invocation.isMethod && #cast == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 0; i++)
        positionalArguments.add(null);

      return target.cast();
    }
    if (invocation.isGetter && #isBroadcast == invocation.memberName) {
      return target.isBroadcast;
    }
    if (invocation.isGetter && #hashCode == invocation.memberName) {
      return target.hashCode;
    }
    if (invocation.isGetter && #runtimeType == invocation.memberName) {
      return target.runtimeType;
    }
    if (invocation.isGetter && #isBroadcast == invocation.memberName) {
      return target.isBroadcast;
    }
    if (invocation.isGetter && #length == invocation.memberName) {
      return target.length;
    }
    if (invocation.isGetter && #isEmpty == invocation.memberName) {
      return target.isEmpty;
    }
    if (invocation.isGetter && #first == invocation.memberName) {
      return target.first;
    }
    if (invocation.isGetter && #last == invocation.memberName) {
      return target.last;
    }
    if (invocation.isGetter && #single == invocation.memberName) {
      return target.single;
    }
    if (invocation.isMethod && #asBroadcastStream == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 0; i++)
        positionalArguments.add(null);

      return target.asBroadcastStream(
          onListen: invocation.namedArguments[#onListen],
          onCancel: invocation.namedArguments[#onCancel]);
    }
    if (invocation.isMethod && #listen == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 1; i++)
        positionalArguments.add(null);

      return target.listen(positionalArguments[0],
          onError: invocation.namedArguments[#onError],
          onDone: invocation.namedArguments[#onDone],
          cancelOnError: invocation.namedArguments[#cancelOnError]);
    }
    if (invocation.isMethod && #== == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 1; i++)
        positionalArguments.add(null);

      return target == positionalArguments[0];
    }
    if (invocation.isMethod && #toString == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 0; i++)
        positionalArguments.add(null);

      return target.toString();
    }
    if (invocation.isMethod && #noSuchMethod == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 1; i++)
        positionalArguments.add(null);

      return target.noSuchMethod(
        positionalArguments[0],
      );
    }
    if (invocation.isMethod && #asBroadcastStream == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 0; i++)
        positionalArguments.add(null);

      return target.asBroadcastStream(
          onListen: invocation.namedArguments[#onListen],
          onCancel: invocation.namedArguments[#onCancel]);
    }
    if (invocation.isMethod && #listen == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 1; i++)
        positionalArguments.add(null);

      return target.listen(positionalArguments[0],
          onError: invocation.namedArguments[#onError],
          onDone: invocation.namedArguments[#onDone],
          cancelOnError: invocation.namedArguments[#cancelOnError]);
    }
    if (invocation.isMethod && #where == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 1; i++)
        positionalArguments.add(null);

      return target.where(
        positionalArguments[0],
      );
    }
    if (invocation.isMethod && #map == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 1; i++)
        positionalArguments.add(null);

      return target.map(
        positionalArguments[0],
      );
    }
    if (invocation.isMethod && #asyncMap == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 1; i++)
        positionalArguments.add(null);

      return target.asyncMap(
        positionalArguments[0],
      );
    }
    if (invocation.isMethod && #asyncExpand == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 1; i++)
        positionalArguments.add(null);

      return target.asyncExpand(
        positionalArguments[0],
      );
    }
    if (invocation.isMethod && #handleError == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 1; i++)
        positionalArguments.add(null);

      return target.handleError(positionalArguments[0],
          test: invocation.namedArguments[#test]);
    }
    if (invocation.isMethod && #expand == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 1; i++)
        positionalArguments.add(null);

      return target.expand(
        positionalArguments[0],
      );
    }
    if (invocation.isMethod && #pipe == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 1; i++)
        positionalArguments.add(null);

      return target.pipe(
        positionalArguments[0],
      );
    }
    if (invocation.isMethod && #transform == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 1; i++)
        positionalArguments.add(null);

      return target.transform(
        positionalArguments[0],
      );
    }
    if (invocation.isMethod && #reduce == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 1; i++)
        positionalArguments.add(null);

      return target.reduce(
        positionalArguments[0],
      );
    }
    if (invocation.isMethod && #fold == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 2; i++)
        positionalArguments.add(null);

      return target.fold(
        positionalArguments[0],
        positionalArguments[1],
      );
    }
    if (invocation.isMethod && #join == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 1; i++)
        positionalArguments.add(null);

      return target.join(
        positionalArguments[0],
      );
    }
    if (invocation.isMethod && #contains == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 1; i++)
        positionalArguments.add(null);

      return target.contains(
        positionalArguments[0],
      );
    }
    if (invocation.isMethod && #forEach == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 1; i++)
        positionalArguments.add(null);

      return target.forEach(
        positionalArguments[0],
      );
    }
    if (invocation.isMethod && #every == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 1; i++)
        positionalArguments.add(null);

      return target.every(
        positionalArguments[0],
      );
    }
    if (invocation.isMethod && #any == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 1; i++)
        positionalArguments.add(null);

      return target.any(
        positionalArguments[0],
      );
    }
    if (invocation.isMethod && #cast == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 0; i++)
        positionalArguments.add(null);

      return target.cast();
    }
    if (invocation.isMethod && #toList == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 0; i++)
        positionalArguments.add(null);

      return target.toList();
    }
    if (invocation.isMethod && #toSet == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 0; i++)
        positionalArguments.add(null);

      return target.toSet();
    }
    if (invocation.isMethod && #drain == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 1; i++)
        positionalArguments.add(null);

      return target.drain(
        positionalArguments[0],
      );
    }
    if (invocation.isMethod && #take == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 1; i++)
        positionalArguments.add(null);

      return target.take(
        positionalArguments[0],
      );
    }
    if (invocation.isMethod && #takeWhile == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 1; i++)
        positionalArguments.add(null);

      return target.takeWhile(
        positionalArguments[0],
      );
    }
    if (invocation.isMethod && #skip == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 1; i++)
        positionalArguments.add(null);

      return target.skip(
        positionalArguments[0],
      );
    }
    if (invocation.isMethod && #skipWhile == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 1; i++)
        positionalArguments.add(null);

      return target.skipWhile(
        positionalArguments[0],
      );
    }
    if (invocation.isMethod && #distinct == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 1; i++)
        positionalArguments.add(null);

      return target.distinct(
        positionalArguments[0],
      );
    }
    if (invocation.isMethod && #firstWhere == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 1; i++)
        positionalArguments.add(null);

      return target.firstWhere(positionalArguments[0],
          orElse: invocation.namedArguments[#orElse]);
    }
    if (invocation.isMethod && #lastWhere == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 1; i++)
        positionalArguments.add(null);

      return target.lastWhere(positionalArguments[0],
          orElse: invocation.namedArguments[#orElse]);
    }
    if (invocation.isMethod && #singleWhere == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 1; i++)
        positionalArguments.add(null);

      return target.singleWhere(positionalArguments[0],
          orElse: invocation.namedArguments[#orElse]);
    }
    if (invocation.isMethod && #elementAt == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 1; i++)
        positionalArguments.add(null);

      return target.elementAt(
        positionalArguments[0],
      );
    }
    if (invocation.isMethod && #timeout == invocation.memberName) {
      List<Object> positionalArguments =
          List.from(invocation.positionalArguments);
      for (int i = invocation.positionalArguments.length; i < 1; i++)
        positionalArguments.add(null);

      return target.timeout(positionalArguments[0],
          onTimeout: invocation.namedArguments[#onTimeout]);
    }
  }
}

// **************************************************************************
// ProxyGenerator
// **************************************************************************

class _$RemoteFutureProxy implements RemoteFuture {
  Provision provideRemote(Context context) {
    List<Object> arguments = [];
    arguments.add(context);
    Map<Symbol, Object> namedArguments = {};

    Invocation _$invocation =
        Invocation.method(#provideRemote, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.positionalArgumentMetadata.add([]);
    metadata.isStream = false;

    return _handle(_$invocation, metadata);
  }

  Object invoke(Invocation invocation) {
    List<Object> arguments = [];
    arguments.add(invocation);
    Map<Symbol, Object> namedArguments = {};

    Invocation _$invocation =
        Invocation.method(#invoke, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.positionalArgumentMetadata.add([]);
    metadata.elementMetadata.add(override);
    metadata.isStream = false;

    return _handle(_$invocation, metadata);
  }

  Stream<dynamic> asStream() {
    List<Object> arguments = [];

    Map<Symbol, Object> namedArguments = {};

    Invocation _$invocation =
        Invocation.method(#asStream, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.isStream = true;

    return _handle(_$invocation, metadata);
  }

  Future<dynamic> catchError(Function onError, {test}) {
    List<Object> arguments = [];
    arguments.add(onError);
    Map<Symbol, Object> namedArguments = {};
    namedArguments.putIfAbsent(#test, () => test);
    Invocation _$invocation =
        Invocation.method(#catchError, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.positionalArgumentMetadata.add([]);
    metadata.namedArgumentMetadata[#test] = [];
    metadata.isStream = false;

    return _handle(_$invocation, metadata);
  }

  Future<S> then<S>(onValue, {Function onError}) {
    List<Object> arguments = [];
    arguments.add(onValue);
    Map<Symbol, Object> namedArguments = {};
    namedArguments.putIfAbsent(#onError, () => onError);
    Invocation _$invocation =
        Invocation.method(#then, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.positionalArgumentMetadata.add([]);
    metadata.namedArgumentMetadata[#onError] = [];
    metadata.isStream = false;

    return _handle(_$invocation, metadata);
  }

  Future<dynamic> whenComplete(action) {
    List<Object> arguments = [];
    arguments.add(action);
    Map<Symbol, Object> namedArguments = {};

    Invocation _$invocation =
        Invocation.method(#whenComplete, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.positionalArgumentMetadata.add([]);
    metadata.isStream = false;

    return _handle(_$invocation, metadata);
  }

  Future<dynamic> timeout(Duration timeLimit, {onTimeout}) {
    List<Object> arguments = [];
    arguments.add(timeLimit);
    Map<Symbol, Object> namedArguments = {};
    namedArguments.putIfAbsent(#onTimeout, () => onTimeout);
    Invocation _$invocation =
        Invocation.method(#timeout, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.positionalArgumentMetadata.add([]);
    metadata.namedArgumentMetadata[#onTimeout] = [];
    metadata.isStream = false;

    return _handle(_$invocation, metadata);
  }

  bool operator ==(dynamic other) {
    List<Object> arguments = [];
    arguments.add(other);
    Map<Symbol, Object> namedArguments = {};

    Invocation _$invocation = Invocation.method(#==, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.positionalArgumentMetadata.add([]);
    metadata.isStream = false;

    return _handle(_$invocation, metadata);
  }

  String toString() {
    List<Object> arguments = [];

    Map<Symbol, Object> namedArguments = {};

    Invocation _$invocation =
        Invocation.method(#toString, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.isStream = false;

    return _handle(_$invocation, metadata);
  }

  dynamic noSuchMethod(Invocation invocation) {
    List<Object> arguments = [];
    arguments.add(invocation);
    Map<Symbol, Object> namedArguments = {};

    Invocation _$invocation =
        Invocation.method(#noSuchMethod, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.positionalArgumentMetadata.add([]);
    metadata.elementMetadata.add(pragma('vm:entry-point'));
    metadata.isStream = false;

    return _handle(_$invocation, metadata);
  }

  InvocationHandlerFunction _handle;
  _$RemoteFutureProxy(this._handle) : super();

  int get hashCode {
    Invocation invocation = Invocation.getter(#hashCode);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.isStream = false;

    return _handle(invocation, metadata);
  }

  Type get runtimeType {
    Invocation invocation = Invocation.getter(#runtimeType);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.isStream = false;

    return _handle(invocation, metadata);
  }
}

class _$RemoteStreamProxy implements RemoteStream {
  Provision provideRemote(Context context) {
    List<Object> arguments = [];
    arguments.add(context);
    Map<Symbol, Object> namedArguments = {};

    Invocation _$invocation =
        Invocation.method(#provideRemote, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.positionalArgumentMetadata.add([]);
    metadata.isStream = false;

    return _handle(_$invocation, metadata);
  }

  Object invoke(Invocation invocation) {
    List<Object> arguments = [];
    arguments.add(invocation);
    Map<Symbol, Object> namedArguments = {};

    Invocation _$invocation =
        Invocation.method(#invoke, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.positionalArgumentMetadata.add([]);
    metadata.elementMetadata.add(override);
    metadata.isStream = false;

    return _handle(_$invocation, metadata);
  }

  Stream<dynamic> asBroadcastStream({onListen, onCancel}) {
    List<Object> arguments = [];

    Map<Symbol, Object> namedArguments = {};
    namedArguments.putIfAbsent(#onListen, () => onListen);
    namedArguments.putIfAbsent(#onCancel, () => onCancel);
    Invocation _$invocation =
        Invocation.method(#asBroadcastStream, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.namedArgumentMetadata[#onListen] = [];
    metadata.namedArgumentMetadata[#onCancel] = [];
    metadata.isStream = true;

    return _handle(_$invocation, metadata);
  }

  StreamSubscription<dynamic> listen(onData,
      {Function onError, onDone, bool cancelOnError}) {
    List<Object> arguments = [];
    arguments.add(onData);
    Map<Symbol, Object> namedArguments = {};
    namedArguments.putIfAbsent(#onError, () => onError);
    namedArguments.putIfAbsent(#onDone, () => onDone);
    namedArguments.putIfAbsent(#cancelOnError, () => cancelOnError);
    Invocation _$invocation =
        Invocation.method(#listen, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.positionalArgumentMetadata.add([]);
    metadata.namedArgumentMetadata[#onError] = [];
    metadata.namedArgumentMetadata[#onDone] = [];
    metadata.namedArgumentMetadata[#cancelOnError] = [];
    metadata.isStream = false;

    return _handle(_$invocation, metadata);
  }

  bool operator ==(dynamic other) {
    List<Object> arguments = [];
    arguments.add(other);
    Map<Symbol, Object> namedArguments = {};

    Invocation _$invocation = Invocation.method(#==, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.positionalArgumentMetadata.add([]);
    metadata.isStream = false;

    return _handle(_$invocation, metadata);
  }

  String toString() {
    List<Object> arguments = [];

    Map<Symbol, Object> namedArguments = {};

    Invocation _$invocation =
        Invocation.method(#toString, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.isStream = false;

    return _handle(_$invocation, metadata);
  }

  dynamic noSuchMethod(Invocation invocation) {
    List<Object> arguments = [];
    arguments.add(invocation);
    Map<Symbol, Object> namedArguments = {};

    Invocation _$invocation =
        Invocation.method(#noSuchMethod, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.positionalArgumentMetadata.add([]);
    metadata.elementMetadata.add(pragma('vm:entry-point'));
    metadata.isStream = false;

    return _handle(_$invocation, metadata);
  }

  Stream<dynamic> where(test) {
    List<Object> arguments = [];
    arguments.add(test);
    Map<Symbol, Object> namedArguments = {};

    Invocation _$invocation =
        Invocation.method(#where, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.positionalArgumentMetadata.add([]);
    metadata.isStream = true;

    return _handle(_$invocation, metadata);
  }

  Stream<S> map<S>(convert) {
    List<Object> arguments = [];
    arguments.add(convert);
    Map<Symbol, Object> namedArguments = {};

    Invocation _$invocation =
        Invocation.method(#map, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.positionalArgumentMetadata.add([]);
    metadata.isStream = true;

    return _handle(_$invocation, metadata);
  }

  Stream<E> asyncMap<E>(convert) {
    List<Object> arguments = [];
    arguments.add(convert);
    Map<Symbol, Object> namedArguments = {};

    Invocation _$invocation =
        Invocation.method(#asyncMap, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.positionalArgumentMetadata.add([]);
    metadata.isStream = true;

    return _handle(_$invocation, metadata);
  }

  Stream<E> asyncExpand<E>(convert) {
    List<Object> arguments = [];
    arguments.add(convert);
    Map<Symbol, Object> namedArguments = {};

    Invocation _$invocation =
        Invocation.method(#asyncExpand, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.positionalArgumentMetadata.add([]);
    metadata.isStream = true;

    return _handle(_$invocation, metadata);
  }

  Stream<dynamic> handleError(Function onError, {test}) {
    List<Object> arguments = [];
    arguments.add(onError);
    Map<Symbol, Object> namedArguments = {};
    namedArguments.putIfAbsent(#test, () => test);
    Invocation _$invocation =
        Invocation.method(#handleError, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.positionalArgumentMetadata.add([]);
    metadata.namedArgumentMetadata[#test] = [];
    metadata.isStream = true;

    return _handle(_$invocation, metadata);
  }

  Stream<S> expand<S>(convert) {
    List<Object> arguments = [];
    arguments.add(convert);
    Map<Symbol, Object> namedArguments = {};

    Invocation _$invocation =
        Invocation.method(#expand, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.positionalArgumentMetadata.add([]);
    metadata.isStream = true;

    return _handle(_$invocation, metadata);
  }

  Future<dynamic> pipe(StreamConsumer streamConsumer) {
    List<Object> arguments = [];
    arguments.add(streamConsumer);
    Map<Symbol, Object> namedArguments = {};

    Invocation _$invocation =
        Invocation.method(#pipe, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.positionalArgumentMetadata.add([]);
    metadata.isStream = false;

    return _handle(_$invocation, metadata);
  }

  Stream<S> transform<S>(StreamTransformer streamTransformer) {
    List<Object> arguments = [];
    arguments.add(streamTransformer);
    Map<Symbol, Object> namedArguments = {};

    Invocation _$invocation =
        Invocation.method(#transform, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.positionalArgumentMetadata.add([]);
    metadata.isStream = true;

    return _handle(_$invocation, metadata);
  }

  Future<dynamic> reduce(combine) {
    List<Object> arguments = [];
    arguments.add(combine);
    Map<Symbol, Object> namedArguments = {};

    Invocation _$invocation =
        Invocation.method(#reduce, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.positionalArgumentMetadata.add([]);
    metadata.isStream = false;

    return _handle(_$invocation, metadata);
  }

  Future<S> fold<S>(S initialValue, combine) {
    List<Object> arguments = [];
    arguments.add(initialValue);
    arguments.add(combine);
    Map<Symbol, Object> namedArguments = {};

    Invocation _$invocation =
        Invocation.method(#fold, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.positionalArgumentMetadata.add([]);
    metadata.positionalArgumentMetadata.add([]);
    metadata.isStream = false;

    return _handle(_$invocation, metadata);
  }

  Future<String> join([String separator]) {
    List<Object> arguments = [];
    arguments.add(separator);
    Map<Symbol, Object> namedArguments = {};

    Invocation _$invocation =
        Invocation.method(#join, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.positionalArgumentMetadata.add([]);
    metadata.isStream = false;

    return _handle(_$invocation, metadata);
  }

  Future<bool> contains(Object needle) {
    List<Object> arguments = [];
    arguments.add(needle);
    Map<Symbol, Object> namedArguments = {};

    Invocation _$invocation =
        Invocation.method(#contains, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.positionalArgumentMetadata.add([]);
    metadata.isStream = false;

    return _handle(_$invocation, metadata);
  }

  Future<dynamic> forEach(action) {
    List<Object> arguments = [];
    arguments.add(action);
    Map<Symbol, Object> namedArguments = {};

    Invocation _$invocation =
        Invocation.method(#forEach, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.positionalArgumentMetadata.add([]);
    metadata.isStream = false;

    return _handle(_$invocation, metadata);
  }

  Future<bool> every(test) {
    List<Object> arguments = [];
    arguments.add(test);
    Map<Symbol, Object> namedArguments = {};

    Invocation _$invocation =
        Invocation.method(#every, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.positionalArgumentMetadata.add([]);
    metadata.isStream = false;

    return _handle(_$invocation, metadata);
  }

  Future<bool> any(test) {
    List<Object> arguments = [];
    arguments.add(test);
    Map<Symbol, Object> namedArguments = {};

    Invocation _$invocation =
        Invocation.method(#any, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.positionalArgumentMetadata.add([]);
    metadata.isStream = false;

    return _handle(_$invocation, metadata);
  }

  Future<List<dynamic>> toList() {
    List<Object> arguments = [];

    Map<Symbol, Object> namedArguments = {};

    Invocation _$invocation =
        Invocation.method(#toList, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.isStream = false;

    return _handle(_$invocation, metadata);
  }

  Future<Set<dynamic>> toSet() {
    List<Object> arguments = [];

    Map<Symbol, Object> namedArguments = {};

    Invocation _$invocation =
        Invocation.method(#toSet, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.isStream = false;

    return _handle(_$invocation, metadata);
  }

  Future<E> drain<E>([E futureValue]) {
    List<Object> arguments = [];
    arguments.add(futureValue);
    Map<Symbol, Object> namedArguments = {};

    Invocation _$invocation =
        Invocation.method(#drain, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.positionalArgumentMetadata.add([]);
    metadata.isStream = false;

    return _handle(_$invocation, metadata);
  }

  Stream<dynamic> take(int count) {
    List<Object> arguments = [];
    arguments.add(count);
    Map<Symbol, Object> namedArguments = {};

    Invocation _$invocation =
        Invocation.method(#take, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.positionalArgumentMetadata.add([]);
    metadata.isStream = true;

    return _handle(_$invocation, metadata);
  }

  Stream<dynamic> takeWhile(test) {
    List<Object> arguments = [];
    arguments.add(test);
    Map<Symbol, Object> namedArguments = {};

    Invocation _$invocation =
        Invocation.method(#takeWhile, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.positionalArgumentMetadata.add([]);
    metadata.isStream = true;

    return _handle(_$invocation, metadata);
  }

  Stream<dynamic> skip(int count) {
    List<Object> arguments = [];
    arguments.add(count);
    Map<Symbol, Object> namedArguments = {};

    Invocation _$invocation =
        Invocation.method(#skip, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.positionalArgumentMetadata.add([]);
    metadata.isStream = true;

    return _handle(_$invocation, metadata);
  }

  Stream<dynamic> skipWhile(test) {
    List<Object> arguments = [];
    arguments.add(test);
    Map<Symbol, Object> namedArguments = {};

    Invocation _$invocation =
        Invocation.method(#skipWhile, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.positionalArgumentMetadata.add([]);
    metadata.isStream = true;

    return _handle(_$invocation, metadata);
  }

  Stream<dynamic> distinct([equals]) {
    List<Object> arguments = [];
    arguments.add(equals);
    Map<Symbol, Object> namedArguments = {};

    Invocation _$invocation =
        Invocation.method(#distinct, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.positionalArgumentMetadata.add([]);
    metadata.isStream = true;

    return _handle(_$invocation, metadata);
  }

  Future<dynamic> firstWhere(test, {orElse}) {
    List<Object> arguments = [];
    arguments.add(test);
    Map<Symbol, Object> namedArguments = {};
    namedArguments.putIfAbsent(#orElse, () => orElse);
    Invocation _$invocation =
        Invocation.method(#firstWhere, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.positionalArgumentMetadata.add([]);
    metadata.namedArgumentMetadata[#orElse] = [];
    metadata.isStream = false;

    return _handle(_$invocation, metadata);
  }

  Future<dynamic> lastWhere(test, {orElse}) {
    List<Object> arguments = [];
    arguments.add(test);
    Map<Symbol, Object> namedArguments = {};
    namedArguments.putIfAbsent(#orElse, () => orElse);
    Invocation _$invocation =
        Invocation.method(#lastWhere, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.positionalArgumentMetadata.add([]);
    metadata.namedArgumentMetadata[#orElse] = [];
    metadata.isStream = false;

    return _handle(_$invocation, metadata);
  }

  Future<dynamic> singleWhere(test, {orElse}) {
    List<Object> arguments = [];
    arguments.add(test);
    Map<Symbol, Object> namedArguments = {};
    namedArguments.putIfAbsent(#orElse, () => orElse);
    Invocation _$invocation =
        Invocation.method(#singleWhere, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.positionalArgumentMetadata.add([]);
    metadata.namedArgumentMetadata[#orElse] = [];
    metadata.isStream = false;

    return _handle(_$invocation, metadata);
  }

  Future<dynamic> elementAt(int index) {
    List<Object> arguments = [];
    arguments.add(index);
    Map<Symbol, Object> namedArguments = {};

    Invocation _$invocation =
        Invocation.method(#elementAt, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.positionalArgumentMetadata.add([]);
    metadata.isStream = false;

    return _handle(_$invocation, metadata);
  }

  Stream<dynamic> timeout(Duration timeLimit, {onTimeout}) {
    List<Object> arguments = [];
    arguments.add(timeLimit);
    Map<Symbol, Object> namedArguments = {};
    namedArguments.putIfAbsent(#onTimeout, () => onTimeout);
    Invocation _$invocation =
        Invocation.method(#timeout, arguments, namedArguments);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.positionalArgumentMetadata.add([]);
    metadata.namedArgumentMetadata[#onTimeout] = [];
    metadata.isStream = true;

    return _handle(_$invocation, metadata);
  }

  InvocationHandlerFunction _handle;
  _$RemoteStreamProxy(this._handle) : super();

  bool get isBroadcast {
    Invocation invocation = Invocation.getter(#isBroadcast);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.isStream = false;

    return _handle(invocation, metadata);
  }

  int get hashCode {
    Invocation invocation = Invocation.getter(#hashCode);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.isStream = false;

    return _handle(invocation, metadata);
  }

  Type get runtimeType {
    Invocation invocation = Invocation.getter(#runtimeType);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.isStream = false;

    return _handle(invocation, metadata);
  }

  Future<int> get length {
    Invocation invocation = Invocation.getter(#length);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.isStream = false;

    return _handle(invocation, metadata);
  }

  Future<bool> get isEmpty {
    Invocation invocation = Invocation.getter(#isEmpty);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.isStream = false;

    return _handle(invocation, metadata);
  }

  Future<dynamic> get first {
    Invocation invocation = Invocation.getter(#first);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.isStream = false;

    return _handle(invocation, metadata);
  }

  Future<dynamic> get last {
    Invocation invocation = Invocation.getter(#last);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.isStream = false;

    return _handle(invocation, metadata);
  }

  Future<dynamic> get single {
    Invocation invocation = Invocation.getter(#single);

    InvocationMetadata metadata = new InvocationMetadata();
    metadata.isStream = false;

    return _handle(invocation, metadata);
  }
}

// **************************************************************************
// RmiGenerator
// **************************************************************************

class _$RemoteFutureRmi {
  static void _registerSerializers(Context context) {}
  static void _registerStubConstructors(Context context) {
    context.registerRemoteStubConstructor(
        'asset:rmi/lib/src/standard_object.dart#RemoteFuture', getRemote);
  }

  static RemoteFuture getRemote(Context context, String uuid) {
    _registerSerializers(context);
    _registerStubConstructors(context);
    RmiProxyHandler handler = RmiProxyHandler(context, uuid);
    return _$RemoteFutureProxy(handler.handle);
  }

  static Provision provideRemote(Context context, RemoteFuture target) {
    _registerSerializers(context);
    _registerStubConstructors(context);
    return rmiProvideRemote(
        context, target, 'asset:rmi/lib/src/standard_object.dart#RemoteFuture');
  }
}

class _$RemoteStreamRmi {
  static void _registerSerializers(Context context) {}
  static void _registerStubConstructors(Context context) {
    context.registerRemoteStubConstructor(
        'asset:rmi/lib/src/standard_object.dart#RemoteStream', getRemote);
  }

  static RemoteStream getRemote(Context context, String uuid) {
    _registerSerializers(context);
    _registerStubConstructors(context);
    RmiProxyHandler handler = RmiProxyHandler(context, uuid);
    return _$RemoteStreamProxy(handler.handle);
  }

  static Provision provideRemote(Context context, RemoteStream target) {
    _registerSerializers(context);
    _registerStubConstructors(context);
    return rmiProvideRemote(
        context, target, 'asset:rmi/lib/src/standard_object.dart#RemoteStream');
  }
}
